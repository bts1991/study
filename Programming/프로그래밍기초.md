## OOP 객체 지향 프로그래밍이란?
- 데이터나 메서드 등의 객체를 중심으로, 여러 객체가 서로 상호작용하도록 프로그램을을 구성하는 방식이다. 객체 지향 프로그램은 코드의 재사용성, 유지보수성, 확장성이 높다. 
- 상속, 추상화 같은 기법이 있다.
## C와 파이썬의 차이
- C는 기계어에 가까운 저수준의 언어로 개발자가 메모리를 직접 관리하고 변수 선언 시 데이터 형식을 직접 명시해야 하는 등 문법이 복잡하지만 실행 속도가 빠르며, 
- 파이썬은 인간 언어에 가까운 고수준의 언어로 자동으로 메모리를 할당하고, 동적으로 데이터 타입이 선언되는 등 문법인 간결하고 쉬우나, C 보다는 속도가 느리다.
## 리스트와 딕셔너리의 차이
- 리스트는 특정 순서로 데이터를 나열한 자료 구조이고 인덱스로 접근하며
- 딕셔너리는 Key와 Value의 쌍으로 데이터가 나열된 자료구조이고 키로 접근한다.
## 배열과 리스트의 차이
- 배열과 리스트는 자료를 순서대로 나열한다는 공통점이 있지만, 배열은 동일한 타입의 자료만 담을 수 있고, 리스트는 서로 다른 타입의 자료도 담을 수 있다. 리스트 보다는 배열의 계산이 더 빠르다.
## Linked List 란?
- 데이터를 저장할 때, 각 노드가 자신의 값과 다음 노드의 주소를 함께 저장하는 자료구조
## Linked List와 배열의 차이?
| 항목               | 배열 (Array)                        | 연결 리스트 (Linked List)                                   |
| ---------------- | --------------------------------- | ------------------------------------------------------ |
| **메모리 구조**       | 연속된 메모리 공간에 저장                    | 노드들이 포인터로 연결된 구조                                       |
| **메모리 할당**       | 정적(크기 고정) 또는 동적 (ex. Python list) | 동적 (필요할 때마다 노드 생성)                                     |
| **접근 속도**        | 임의 접근 `O(1)` → 빠름                 | 순차 접근 `O(n)` → 느림                                      |
| **삽입/삭제 (중간/앞)** | 느림 `O(n)` (이동 필요)                 | 빠름 `O(1)` \~ `O(n)` (포인터 변경)                           |
| **삽입/삭제 (끝)**    | 빠름 (Python list 기준 `append`)      | 단일 연결리스트는 느림 (`O(n)`), 이중 연결리스트 또는 tail 포인터 있으면 `O(1)` |
| **메모리 사용**       | 요소만 저장 (공간 효율적)                   | 데이터 + 포인터 필요 (오버헤드 있음)                                 |
| **캐시 친화성**       | 좋음 (연속 메모리, CPU 캐시에 잘 맞음)         | 나쁨 (비연속 메모리, 캐시 효율 낮음)                                 |
| **정렬/검색**        | 이진 탐색 가능 `O(log n)`               | 이진 탐색 불가 (선형 탐색만 가능)                                   |
| **사용 예**         | 이미지 배열, 행렬 계산 등 연속 데이터            | 큐, 스택, 트리, 그래프 등 동적 구조                                 |

| 상황               | 추천 구조  |
| ---------------- | ------ |
| 빠른 인덱스 접근이 필요할 때 | 배열     |
| 삽입/삭제가 빈번할 때     | 연결 리스트 |
| 메모리 크기를 예측 가능할 때 | 배열     |
| 유동적으로 크기가 변할 때   | 연결 리스트 |
| 캐시 성능이 중요한 연산일 때 | 배열     |


## 포인터 란?
- 변수나 데이터가 저장된 메모리의 주소를 저장하는 변수, 즉 값이 저장된 위치(주소)를 저장
- 값 자체가 아닌, 값이 어디 있는지를 가리킴
## 시간복잡도 $O$ 란?
- 입력 크기 n이 커질 때, 알고리즘이 수행하는 연산 수의 증가율을 나타내는 척도
- 빅오 표기법(Big-O)으로 표현하며, 최악의 경우에 대한 연산량을 제공

    | 시간복잡도          | 설명                | 예시            |
    | -------------- | ----------------- | ------------- |
    | **O(1)**       | 상수 시간, 입력 크기와 무관  | 배열 접근 arr\[5] |
    | **O(log n)**   | 로그 시간, 입력이 반씩 줄어듦 | 이진 탐색         |
    | **O(n)**       | 선형 시간             | 단일 for문       |
    | **O(n log n)** | 로그 성분 포함된 선형      | 병합정렬, 퀵정렬 평균  |
    | **O(n²)**      | 이중 반복문            | 버블 정렬, 삽입 정렬  |
    | **O(2ⁿ)**      | 지수 시간             | 피보나치 재귀       |
    | **O(n!)**      | 팩토리얼 시간           | 순열 생성         |


## 멀티쓰레드(Multi-thread)와 멀티프로세스(Multi-process)의 차이
✅ 1. 멀티스레드(Multi-thread)
    📌 정의:
            하나의 프로세스 내에서 여러 개의 **스레드(Thread)**가 생성되어 작업을 병렬로 수행하는 방식.

            모든 스레드는 메모리(코드, 데이터, 힙)를 공유함. 효율적인 자원 사용과 빠른 통신 가능

    💡 예:
            워드 프로세서에서 자동 저장, 타이핑, 맞춤법 검사를 동시에 실행

    ✔️ 장점:
            스레드 간 데이터 공유가 쉬움
            자원 소모가 적음 (프로세스보다 메모리 부담 적음)
            컨텍스트 스위칭 비용이 작음
            IO-bound 작업에 유리
                - 입출력(I/O, Input/Output) 때문에 작업 속도가 제한되는 경우(디스크에서 파일 읽기/쓰기, 웹 요청 보내고 응답 기다리기)

    ❗ 단점:
            하나의 스레드에서 오류가 발생하면 전체 프로세스가 죽을 수 있음
            **동기화 문제(데이터 충돌)**가 발생하기 쉬움 → 락(lock) 관리 필요

✅ 2. 멀티프로세스(Multi-process)
    📌 정의:
            여러 개의 **독립된 프로세스(Process)**가 각각 자신만의 메모리 공간을 사용하며 실행
            각 프로세스는 완전히 별개로 동작함 → 진정한 병렬 처리 가능

    💡 예:
            크롬 브라우저의 각 탭은 별도 프로세스로 실행됨 (하나 죽어도 나머지는 영향 없음)

    ✔️ 장점:
            하나의 프로세스가 죽어도 전체 시스템에는 영향 없음
            병렬 처리가 안전함 (메모리 공유 안 해서 충돌 적음)
            CPU-bound 작업에 매우 효과적
                - CPU 계산이 집중되는 작업에서 특히 좋은 성능(수학 연산 (큰 수의 소인수분해), 대규모 행렬 연산, 선형대수 계산, 머신러닝 모델 학습, 이미지 처리, 영상 인코딩)

    ❗ 단점:
            프로세스끼리 독립되기에 프로세스 사이에서 공유할 자원이 있다면 복잡하고 느린, 프로세스 간 통신 메커니즘(IPC)을 활용(IPC, Inter-Process Communication)

            자원 소비가 많음 (각자 메모리, 스택 등 독립적으로 할당)




## 스택메모리와 힙메모리의 차이
## 리스트와 튜플의 차이
## 클래스와 인스턴스의 차이
## 변수의 SCOPE
## 딕셔너리와 해시테이블의 차이
## for문과 while문의 차이
## 예외 처리란 무엇이며, 왜 필요한가?
## deep copy와 copy의 차이
## 모든 클래스는 초기화 함수로 무엇을 사용하는가?
## 상속, 추상, 인터페이스란?
## 재귀함수란?
## numpy의 axis 연산이란?
## numpy의 sum, max, armax 란?
## 람다 함수란?
