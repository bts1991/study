## OOP 객체 지향 프로그래밍이란?
- 데이터나 메서드 등의 객체를 중심으로, 여러 객체가 서로 상호작용하도록 프로그램을을 구성하는 방식이다. 객체 지향 프로그램은 코드의 재사용성, 유지보수성, 확장성이 높다. 
- 상속, 추상화 같은 기법이 있다.
## C와 파이썬의 차이
- C는 기계어에 가까운 저수준의 언어로 개발자가 메모리를 직접 관리하고 변수 선언 시 데이터 형식을 직접 명시해야 하는 등 문법이 복잡하지만 실행 속도가 빠르며, 
- 파이썬은 인간 언어에 가까운 고수준의 언어로 자동으로 메모리를 할당하고, 동적으로 데이터 타입이 선언되는 등 문법인 간결하고 쉬우나, C 보다는 속도가 느리다.
## 리스트와 딕셔너리의 차이
- 리스트는 특정 순서로 데이터를 나열한 자료 구조이고 인덱스로 접근하며
- 딕셔너리는 Key와 Value의 쌍으로 데이터가 나열된 자료구조이고 키로 접근한다.
## 배열과 리스트의 차이
- 배열과 리스트는 자료를 순서대로 나열한다는 공통점이 있지만, 배열은 동일한 타입의 자료만 담을 수 있고, 리스트는 서로 다른 타입의 자료도 담을 수 있다. 리스트 보다는 배열의 계산이 더 빠르다.
## Linked List 란?
- 데이터를 저장할 때, 각 노드가 자신의 값과 다음 노드의 주소를 함께 저장하는 자료구조
## Linked List와 배열의 차이?
| 항목               | 배열 (Array)                        | 연결 리스트 (Linked List)                                   |
| ---------------- | --------------------------------- | ------------------------------------------------------ |
| **메모리 구조**       | 연속된 메모리 공간에 저장                    | 노드들이 포인터로 연결된 구조                                       |
| **메모리 할당**       | 정적(크기 고정) 또는 동적 (ex. Python list) | 동적 (필요할 때마다 노드 생성)                                     |
| **접근 속도**        | 임의 접근 `O(1)` → 빠름                 | 순차 접근 `O(n)` → 느림                                      |
| **삽입/삭제 (중간/앞)** | 느림 `O(n)` (이동 필요)                 | 빠름 `O(1)` \~ `O(n)` (포인터 변경)                           |
| **삽입/삭제 (끝)**    | 빠름 (Python list 기준 `append`)      | 단일 연결리스트는 느림 (`O(n)`), 이중 연결리스트 또는 tail 포인터 있으면 `O(1)` |
| **메모리 사용**       | 요소만 저장 (공간 효율적)                   | 데이터 + 포인터 필요 (오버헤드 있음)                                 |
| **캐시 친화성**       | 좋음 (연속 메모리, CPU 캐시에 잘 맞음)         | 나쁨 (비연속 메모리, 캐시 효율 낮음)                                 |
| **정렬/검색**        | 이진 탐색 가능 `O(log n)`               | 이진 탐색 불가 (선형 탐색만 가능)                                   |
| **사용 예**         | 이미지 배열, 행렬 계산 등 연속 데이터            | 큐, 스택, 트리, 그래프 등 동적 구조                                 |

| 상황               | 추천 구조  |
| ---------------- | ------ |
| 빠른 인덱스 접근이 필요할 때 | 배열     |
| 삽입/삭제가 빈번할 때     | 연결 리스트 |
| 메모리 크기를 예측 가능할 때 | 배열     |
| 유동적으로 크기가 변할 때   | 연결 리스트 |
| 캐시 성능이 중요한 연산일 때 | 배열     |


## 포인터 란?
- 변수나 데이터가 저장된 메모리의 주소를 저장하는 변수, 즉 값이 저장된 위치(주소)를 저장
- 값 자체가 아닌, 값이 어디 있는지를 가리킴
## 시간복잡도 $O$ 란?
- 입력 크기 n이 커질 때, 알고리즘이 수행하는 연산 수의 증가율을 나타내는 척도
- 빅오 표기법(Big-O)으로 표현하며, 최악의 경우에 대한 연산량을 제공

    | 시간복잡도          | 설명                | 예시            |
    | -------------- | ----------------- | ------------- |
    | **O(1)**       | 상수 시간, 입력 크기와 무관  | 배열 접근 arr\[5] |
    | **O(log n)**   | 로그 시간, 입력이 반씩 줄어듦 | 이진 탐색         |
    | **O(n)**       | 선형 시간             | 단일 for문       |
    | **O(n log n)** | 로그 성분 포함된 선형      | 병합정렬, 퀵정렬 평균  |
    | **O(n²)**      | 이중 반복문            | 버블 정렬, 삽입 정렬  |
    | **O(2ⁿ)**      | 지수 시간             | 피보나치 재귀       |
    | **O(n!)**      | 팩토리얼 시간           | 순열 생성         |


## 멀티쓰레드(Multi-thread)와 멀티프로세스(Multi-process)의 차이
✅ 1. 멀티스레드(Multi-thread)
    📌 정의:
            하나의 프로세스 내에서 여러 개의 **스레드(Thread)**가 생성되어 작업을 병렬로 수행하는 방식.

            모든 스레드는 메모리(코드, 데이터, 힙)를 공유함. 효율적인 자원 사용과 빠른 통신 가능

    💡 예:
            워드 프로세서에서 자동 저장, 타이핑, 맞춤법 검사를 동시에 실행

    ✔️ 장점:
            스레드 간 데이터 공유가 쉬움
            자원 소모가 적음 (프로세스보다 메모리 부담 적음)
            컨텍스트 스위칭 비용이 작음
            IO-bound 작업에 유리
                - 입출력(I/O, Input/Output) 때문에 작업 속도가 제한되는 경우(디스크에서 파일 읽기/쓰기, 웹 요청 보내고 응답 기다리기)

    ❗ 단점:
            하나의 스레드에서 오류가 발생하면 전체 프로세스가 죽을 수 있음
            **동기화 문제(데이터 충돌)**가 발생하기 쉬움 → 락(lock) 관리 필요

✅ 2. 멀티프로세스(Multi-process)
    📌 정의:
            여러 개의 **독립된 프로세스(Process)**가 각각 자신만의 메모리 공간을 사용하며 실행
            각 프로세스는 완전히 별개로 동작함 → 진정한 병렬 처리 가능

    💡 예:
            크롬 브라우저의 각 탭은 별도 프로세스로 실행됨 (하나 죽어도 나머지는 영향 없음)

    ✔️ 장점:
            하나의 프로세스가 죽어도 전체 시스템에는 영향 없음
            병렬 처리가 안전함 (메모리 공유 안 해서 충돌 적음)
            CPU-bound 작업에 매우 효과적
                - CPU 계산이 집중되는 작업에서 특히 좋은 성능(수학 연산 (큰 수의 소인수분해), 대규모 행렬 연산, 선형대수 계산, 머신러닝 모델 학습, 이미지 처리, 영상 인코딩)

    ❗ 단점:
            프로세스끼리 독립되기에 프로세스 사이에서 공유할 자원이 있다면 복잡하고 느린, 프로세스 간 통신 메커니즘(IPC)을 활용(IPC, Inter-Process Communication)

            자원 소비가 많음 (각자 메모리, 스택 등 독립적으로 할당)


## 스택메모리와 힙메모리의 차이
- 작고 빠른 스택에는 주소만 저장하고, 크고 유동적인 데이터는 힙에 따로 저장하면,프로그램이 더 빠르고, 메모리 관리가 쉬움
  
| 항목           | **스택 메모리**               | **힙 메모리**                        |
| ------------ | ------------------------ | -------------------------------- |
| **주요 용도**    | 함수 호출 시 지역 변수 저장         | 동적 메모리 할당, 참조형 객체 저장             |
| **할당 방식**    | 컴파일 타임 또는 함수 호출 시 자동 할당  | 실행 중(runtime) 동적 할당              |
| **해제 방식**    | 함수 종료 시 자동 해제 (LIFO)     | 개발자 또는 가비지 컬렉터에 의해 해제            |
| **데이터 크기**   | 작고 고정된 크기 (정적 데이터)       | 크기 제한이 없고 유연 (가변 데이터)            |
| **접근 속도**    | 빠름 (메모리 바로 접근)           | 느림 (포인터로 간접 접근)                  |
| **저장되는 데이터** | 지역 변수, 함수 매개변수, 참조 주소    | 리스트, 딕셔너리, 클래스 인스턴스 등 실제 참조형 데이터 |
| **주소 저장 여부** | 실제 값 또는 참조(주소) 저장        | 참조된 값 자체가 저장됨                    |
| **메모리 구조**   | 선입후출(Last In, First Out) | 자유롭게 할당 (Free List 기반)           |
| **대표 오류**    | 스택 오버플로우(Stack Overflow) | 메모리 누수(Memory Leak)              |
| **언어 처리 예**  | Python에서 지역 변수 등 자동 처리   | Python의 객체, 리스트, 클래스 등 모두 힙에 저장됨 |

## 리스트와 튜플의 차이
- 리스트와 튜플 모두 순서대로 나열된 자료구조
- 리스트는 변경할 수 있으나, 튜플은 변경 불가
- 단, 튜플이 가변적인 리스트를 변수로 가지고 있으면, 그 리스트는 변경 가능
## 클래스와 인스턴스의 차이
- 클래스는 일종의 설계도로 속성과 메서드로 구성
- 인스턴스는 클래스를 호출하여 실체화 한 것
## 변수의 SCOPE
- 크게 전역 변수(global)와 지역 변수(local)로 구분
- 전역 변수는 특정 클래스 전체에서 사용할 수 있고
- 지역 변수는 해당 메서드 에서만 사용할 수 있음
## 딕셔너리와 해시테이블의 차이
- 딕셔너리는 해시테이블을 기반으로 파이썬에서 고도화한 자료구조
- Key와 Value의 쌍으로 이루어져 있고
- 더 나은 점: 메모리 최적화된 구현, 충돌 해결 방식 최적화 등 
## for문과 while문의 차이
- 둘 다 반복문 이지만, 
- for 문은 정해진 회수를 반복하고
- while 문은 특정 조건 하에서 계속 반복
## 재귀함수란?
- 자기자신을 호출하는 함수로 특정 조건 하에서 종료됨
- 예를 들어, heap 자료구조에서 삽입이나 삭제가 발생할 때, max나 min 등 조건을 만족할 때까지 heapify()라는 순서 정렬 함수를 구현하여 계속 호출
## 예외 처리란 무엇이며, 왜 필요한가?
- 프로그램의 비정상적 종료를 방지하며
- 예외가 발생할 때 사용자에게 의미있는 메시지를 전달함
- 보통 try~except 구분으로 작성
## deep copy와 copy의 차이
- copy()는 얕은 복사로, 객체는 새로 만들지만 내부 참조 객체는 공유함
- deepcopy()는 객체와 내부 참조까지 전부 새로 복사, 완전 독립적
- 얕은 복사에서, 내부 객체를 변경하면 원본도 같이 바뀔 수 있음
        import copy

        # 원본 리스트
        original = [[1, 2], [3, 4]]

        # 얕은 복사
        shallow = copy.copy(original)

        # 깊은 복사
        deep = copy.deepcopy(original)

        # 내부 객체 수정
        shallow[0][0] = 100

        print(original)  # [[100, 2], [3, 4]] → 원본도 같이 바뀜
        print(deep)      # [[1, 2], [3, 4]] → deepcopy는 영향 없음

## 모든 클래스는 초기화 함수로 무엇을 사용하는가?
- 모든 클래스는 객체 생성 시 `__init__()` 메서드를 초기화 함수로 사용
- 객체가 생성될 때 **자동으로 호출되며**, 별도로 호출하지 않아도 됨
- 이 함수 안에서 정의된 속성값들은 객체 생성 시 자동으로 설정됨

## 상속, 추상, 인터페이스란?
- 객체 지향 프로그래밍(OOP)의 핵심 개념
- 구조적 설계, 코드 재사용, 확장성, 다형성을 지원하기 위해 사용
- 상속: 자식 클래스는 부모 클래스의 속성이나 메소드을 그대로 상속받아 사용하거나, 오버라이딩하여 재정의. 주로 super() 함수로 호출
- 추상: 추상 클래스는 하나 이상의 추상 메서드(정의만 있고 구현은 없는 메서드)를 가진 클래스로 직접 객체를 생성할 수 없고, 상속받은 자식 클래스에서 추상 메서드를 반드시 구현해야 함
- 인터페이스: 인터페이스 클래스는 모든 메서드가 추상 메서드로만 구성된 일종의 추상 클래스로 **속성 없이, 오직 메서드 정의(명세)**만으로 구성됨 
  - 다형성 이란? 같은 이름의 메서드가 다른 객체에서 다르게 동작

## numpy의 axis 연산이란?
- axis는 다차원 배열에서 연산이 적용되는 축
- 특정 행렬에 대해 axis를 기준으로 연산을 할 수 있다.
- 예를 들어 행렬 A가 $m\times n\times k$ 이고, axis=0 이라면, axis=0을 축으로 수행된다.
- 즉, $m$의 각 원소에 대해 $n\times k$ 끼리 연산이 이루어진다.

| `axis` 값 | 의미                            | 연산 방향     |
| -------- | ----------------------------- | --------- |
| `axis=0` | **행을 따라 연산 (열 기준으로 집계)**      | 세로 방향 (↓) |
| `axis=1` | **열을 따라 연산 (행 기준으로 집계)**      | 가로 방향 (→) |
| `axis=2` | 3차원 이상의 배열에서 **3번째 축을 따라 연산** | 깊이 방향     |


## numpy의 sum, max, armax 란?
- np.sum() 은 합계
- np.max() 는 최대값 
- np.argmax() 는 최대깂의 인덱스
  
## 람다 함수란?
- 익명 함수를 만드는 방법으로, 한 줄로 간단한 함수를 정의할 때 사용
- "lambda 인자: 반환값_표현식" 형태로 표현되며, return 문은 사용하지 않지만, 콜론 뒤 표현식의 결과가 자동으로 반환
- 인공신경망을 학습할 때, 가중치 W에 대한 손실함수의 미분을 구하기 위해  "lambda W: 손실함수" 와 같이 사용한다.
